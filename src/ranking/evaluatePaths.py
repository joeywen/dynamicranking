'''
Created on Jan 29, 2011

@author: Christie

Contains code for evaluating paths generated by createPaths.
Utilizes readInputFl and calcUtilities.
'''

import os.path
import tempfile
import shutil
import ranking.readInputFl;
import ranking.calcUtilities;
import re
import utils.flExts
'''
Performs evaluation of paths provided.  See documentation for 
full description of parameters.
'''
def evaluatePaths(inputDir, pathDir, outputDir, metrics=['DCG'], cutoff=10,
                  verbosity = 1):
    try:
        if not os.path.exists(outputDir):
            os.mkdir(outputDir)
        for fl in os.listdir(pathDir):
            pathFl = os.path.join(pathDir, fl)
            if (not fl.startswith('.') and not os.path.isdir(pathFl)\
                and fl.endswith(utils.flExts.pathExt)):
                (topicId, _, _) = fl.partition('_')
                (baseFlnm,_,_) = fl.partition('.')
                inputFl = os.path.join(inputDir, topicId+utils.flExts.inputExt)
                for evalMet in metrics:
                    outputFl = os.path.join(outputDir, baseFlnm+'_'+evalMet+\
                                            utils.flExts.evalExt)
                    evaluateTopicPaths(inputFl, pathFl,outputFl, topicId,evalMet, cutoff)

    except:
        utils.errorWr.wrErr(True)
'''
Evaluates a path file and writes out the output.
'''
def evaluateTopicPaths(inputFl, pathFl, outputFl, topicId, metric, cutoff):
    profiles = ranking.readInputFl.readInputFl(inputFl,topicId)
    #path files can be quite large, so it opens and processes

    #the path file line-by-line.
    with open(pathFl) as pthFl:
        metricFun = ranking.calcUtilities.getMetricFunction(metric)
        with tempfile.NamedTemporaryFile('r+',delete=False) as tmpF:
            for line in pthFl:
                #15017299068   1   5  d4 : 0 d4:0 d1:0 d3:1 d2:0
                (usell,ll) = utils.utils.stripComments(line)
                if (usell):
                    lline = re.sub('\s:\s', ':', ll)
                    lst = lline.split(None)
                    instId = lst[0]
                    tTopicId = lst[1]
                    if topicId ==tTopicId:
                        profileId = lst[2]
                        path = []
                        
                        for dc in lst[3:len(lst)]:
                            (d,_,c) = dc.partition(':')
                            path.append(d)
                            if profiles.getDocRelMap(profileId) == None:
                                raise Exception('Profile id not found.')
                        docsToRels = dict(profiles.getDocRelMap(profileId))
                        util = metricFun(path, docsToRels, cutoff)
                        tmpF.write(instId+' '+topicId+' '+profileId+' '+str(util)+'\n')
            tmpF.flush()
            tmpF.close()
            shutil.move(tmpF.name, outputFl);
            if (os.path.exists(tmpF.name)):
                os.remove(tmpF.name)
    return outputFl

'''
Reads path file 
@param pathFl the file to read in
@param topicId: the topic id; it only reads instances with this topicId.
@return dictionary of instanceId-->(instanceId, topicId, profileId, path)
'''
def readInPath(pathFl,topicId):
    dd = dict()
    with open(pathFl) as pathFl:
        for line in pathFl:
            lline = re.sub('\s:\s', ':', line)
            lst = lline.split(None)
            instId = lst[0]
            tTopicId = lst[1]
            if topicId ==tTopicId:
                profileId = lst[2]
                path = []
                for dc in lst[3:len(lst)]:
                    (d,_,c) = dc.partition(':')
                    path.append((d,int(c.strip())))
            dd[instId]=(instId,tTopicId,profileId,path)
    if len(dd)==0:
        raise Exception('NO paths with given topic have been found!')
    return dd